#!/usr/bin/env python3

import sys
import threading
import random
import pexpect
import ipaddress
from base64 import b64encode, b64decode

from scapy.all import GRE
from pytun import TunTapDevice
from ssm_talker import SsmTalker

class SsmTunnel(SsmTalker):
    def open_remote_tunnel(self, local_ip, remote_ip):
        def _erase_line():
            print('\x1B[K\r', end="")   # Erase line

        self._logger.debug(f'Creating tunnel')

        # Open remote tun0 device
        self._child.sendline(f"./ssm-tunnel-client {remote_ip} {local_ip}")
        self._child.expect('# Client device .* is ready')
        print(self._child.after, flush=True)

    def open_local_tunnel(self, local_ip, remote_ip):
        tun = TunTapDevice()

        tun.addr = local_ip
        tun.dstaddr = remote_ip
        tun.netmask = '255.255.255.255'
        tun.mtu = 1500

        tun.up()

        print(f"# Local device {tun.name} is ready")
        print(f"# Local IP: {local_ip} / Remote IP: {remote_ip}")

        self._tun = tun

    def local_to_remote(self):
        while True:
            buf = self._tun.read(self._tun.mtu + 4) # Virtual GRE header adds 4 bytes
            self._child.sendline("%{}".format(b64encode(buf).decode('ascii')))
            pkt = GRE(buf)
            #print(">{:4d} {}".format(len(pkt), pkt.summary()))
            #print(buf.hex())

    def remote_to_local(self):
        while True:
            try:
                line = self._child.readline()
            except pexpect.exceptions.TIMEOUT:
                continue
            if line[0]=='%':
                buf = b64decode(line[1:].strip('\r\n'))
                self._tun.write(buf)
                pkt = GRE(buf)
                #print("<{:4d} {}".format(len(pkt), pkt.summary()))
                #print(buf.hex())

    def process_traffic(self):
        tr_l2r = threading.Thread(target=self.local_to_remote, args=[])
        tr_l2r.daemon = True
        tr_l2r.start()

        try:
            self.remote_to_local()

        except KeyboardInterrupt:
            self.exit()
            self._tun.down()
            self._tun.close()

    def start(self, local_ip, remote_ip):
        self.open_remote_tunnel(local_ip, remote_ip)
        self.open_local_tunnel(local_ip, remote_ip)
        self.process_traffic()

def random_ips(network):
    # Network address
    net = ipaddress.ip_network(network)
    # Random host-part
    host_bytes = int(random.uniform(2, 2**(net.max_prefixlen-net.prefixlen)-4))&0xFFFFFFFE
    # Construct local/remote IP
    local_ip = net.network_address + host_bytes
    remote_ip = net.network_address + host_bytes + 1
    return local_ip.compressed, remote_ip.compressed

def main():
    local_ip, remote_ip = random_ips("192.168.0.0/16")
    tunnel = SsmTunnel('i-...', profile='...', region='ap-southeast-2', logger_name='ssm-tunnel')
    tunnel.start(local_ip, remote_ip)

if __name__ == "__main__":
    main()
