#!/usr/bin/env python3

# Set up IP tunnel through SSM-enabled instance.
#
# See https://aws.nz/aws-utils/ssm-tunnel for more info.
#
# Author: Michael Ludvig (https://aws.nz)

import os
import sys
import time
import threading
import random
import struct
import fcntl
import argparse
import ipaddress
from base64 import b64encode, b64decode

import pexpect
import botocore.exceptions

#from scapy.all import GRE

from ssm_common import *
from ssm_talker import SsmTalker
from instance_resolver import InstanceResolver

logger_name = "ssm-tunnel"
tunnel_ips = "100.64.0.0/16"

def parse_args():
    """
    Parse command line arguments.
    """

    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter, add_help=False)

    group_general = add_general_parameters(parser)

    group_instance = parser.add_argument_group('Instance Selection')
    group_instance.add_argument('INSTANCE', nargs='?', help='Instance ID, Name, Host name or IP address')
    group_instance.add_argument('--list', '-l', dest='list', action="store_true", help='List instances registered in SSM.')

    group_network = parser.add_argument_group('Networking Options')
    group_network.add_argument('--route', dest="routes", type=str, action="append", help='CIDR(s) to route through this tunnel. May be used multiple times.')
    group_network.add_argument('--tunnel-ips', type=str, default=tunnel_ips, help=f'''By default the tunnel endpoint IPs
        are randomly derived from the reserved {tunnel_ips} block (RFC6598). This should be ok for most users.''')

    parser.description = 'Start SSM Shell Session to a given instance'
    parser.epilog = f'''
IMPORTANT: instances must be registered in AWS Systems Manager (SSM)
before you can copy files to/from them! Instances not registered in SSM
will not be recognised by {parser.prog} nor show up in --list output.

Visit https://aws.nz/aws-utils/ssm-tunnel for more info and usage examples.

Author: Michael Ludvig
'''

    # Parse supplied arguments
    args = parser.parse_args()

    return args

def run_command(command, assert_0=True):
    print(f"# {command}")
    ret = os.system(command)
    if assert_0:
        assert ret == 0

class SsmTunnel(SsmTalker):
    def open_remote_tunnel(self, local_ip, remote_ip):
        def _erase_line():
            print('\x1B[K\r', end="")   # Erase line

        self._logger.debug(f'Creating tunnel')

        # Open remote tun0 device
        self._child.sendline(f"./ssm-tunnel-client {remote_ip} {local_ip}")
        self._child.expect('# Client device .* is ready')
        print(self._child.after, flush=True)

    def open_local_tunnel(self, local_ip, remote_ip, routes):
        tun_suffix = ".".join(local_ip.split(".")[2:])
        self.tun_name = f"tunSSM.{tun_suffix}"
        self.local_ip = local_ip
        self.remote_ip = remote_ip

        self.create_tun(routes)
        self._tun_fd = self.setup_tun()

        print(f"# Local device {self.tun_name} is ready")
        print(f"# Local IP: {local_ip} / Remote IP: {remote_ip}")

    def create_tun(self, routes):
        try:
            user_id = os.getuid()
            run_command(f"sudo ip tuntap add {self.tun_name} mode tun user {user_id}")
            run_command(f"sudo ip addr add {self.local_ip} peer {self.remote_ip} dev {self.tun_name}")
            run_command(f"sudo ip link set {self.tun_name} up")
            # Configure routes
            for route in routes:
                run_command(f"sudo ip route add {route} via {self.remote_ip}")
        except AssertionError:
            self.delete_tun()
            quit(1)
        except:
            self.delete_tun()
            raise

    def delete_tun(self):
        # We don't check return code here - best effort to close and delete the device
        if self._tun_fd is not None:
            try:
                os.close(self._tun_fd)
            except:
                pass
        run_command(f"sudo ip link set {self.tun_name} down", assert_0=False)
        run_command(f"sudo ip tuntap del {self.tun_name} mode tun", assert_0=False)
        run_command(f"sudo iptables -t nat -D POSTROUTING -m comment --comment \"{self.tun_name}\" -s {self.remote_ip} -j MASQUERADE", assert_0=False)

    def setup_tun(self):
        TUNSETIFF = 0x400454ca
        IFF_TUN = 0x0001

        tun_fd = os.open("/dev/net/tun", os.O_RDWR)

        flags = IFF_TUN
        ifr = struct.pack('16sH22s', self.tun_name.encode(), flags, b'\x00'*22)
        fcntl.ioctl(tun_fd, TUNSETIFF, ifr)

        return tun_fd

    def local_to_remote(self):
        while True:
            buf = os.read(self._tun_fd, 1504)     # Virtual GRE header adds 4 bytes
            self._child.sendline("%{}".format(b64encode(buf).decode('ascii')))
            #pkt = GRE(buf)
            #print(">{:4d} {}".format(len(pkt), pkt.summary()))
            #print(buf.hex())

    def remote_to_local(self):
        while True:
            try:
                line = self._child.readline()
            except pexpect.exceptions.TIMEOUT:
                continue
            if line[0] == '%':
                buf = b64decode(line[1:].strip('\r\n'))
                os.write(self._tun_fd, buf)
                #pkt = GRE(buf)
                #print("<{:4d} {}".format(len(pkt), pkt.summary()))
                #print(buf.hex())

    def process_traffic(self):
        tr_l2r = threading.Thread(target=self.local_to_remote, args=[])
        tr_l2r.daemon = True
        tr_l2r.start()

        try:
            self.remote_to_local()

        except KeyboardInterrupt:
            self.exit()

        finally:
            self.delete_tun()

    def start(self, local_ip, remote_ip, routes):
        self.open_remote_tunnel(local_ip, remote_ip)
        self.open_local_tunnel(local_ip, remote_ip, routes)
        self.process_traffic()

def random_ips(network):
    # Network address
    net = ipaddress.ip_network(network)
    # Random host-part
    host_bytes = int(random.uniform(2, 2**(net.max_prefixlen-net.prefixlen)-4))&0xFFFFFFFE
    # Construct local/remote IP
    local_ip = net.network_address + host_bytes
    remote_ip = net.network_address + host_bytes + 1
    return local_ip.compressed, remote_ip.compressed

def main():
    ## Split command line args
    args = parse_args()

    logger = configure_logging(logger_name, args.log_level)

    try:
        instance_id = None
        if args.list:
            # --list
            InstanceResolver(args).print_list()
            quit(0)

        instance_id = InstanceResolver(args).resolve_instance(args.INSTANCE)
        if not instance_id:
            logger.warning("Could not resolve Instance ID for '%s'", args.INSTANCE)
            logger.warning("Perhaps the '%s' is not registered in SSM?", args.INSTANCE)
            quit(1)

        local_ip, remote_ip = random_ips(args.tunnel_ips)
        tunnel = SsmTunnel(instance_id, profile=args.profile, region=args.region, logger_name=logger_name)
        tunnel.start(local_ip, remote_ip, args.routes or [])

    except (botocore.exceptions.BotoCoreError,
            botocore.exceptions.ClientError) as e:
        logger.error(e)
        quit(1)

if __name__ == "__main__":
    main()
